<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devhua&#39;s Blog</title>
  <subtitle>爱生活，有理想，会思考，能沟通！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.devhua.com/"/>
  <updated>2018-01-08T16:06:17.000Z</updated>
  <id>https://www.devhua.com/</id>
  
  <author>
    <name>洛上倾城华少</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS近期知识总结</title>
    <link href="https://www.devhua.com/2017/12/20/iOS-Learn-Notes/"/>
    <id>https://www.devhua.com/2017/12/20/iOS-Learn-Notes/</id>
    <published>2017-12-20T09:10:32.000Z</published>
    <updated>2018-01-08T16:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-APP之间通信方式有哪些"><a href="#1-APP之间通信方式有哪些" class="headerlink" title="1.APP之间通信方式有哪些"></a>1.APP之间通信方式有哪些</h4><ul>
<li>URL Scheme<br>（在info.plist中配置LSApplicationQueriesSchemes，指定目标app的scheme，然后在目标app的info.plist中配置好URL types）场景：分享，支付等</li>
<li>Keychain<br>本质是sqlite数据库，独立每个app的沙盒之外，即使删除app，keychain中的信息还存在<br>特点：不同app之间需要通过keychain access groups才行，同一个teamID<br>场景：用户登录信息保存，同一平台上多个app之间实现统一账户登录</li>
<li>UIPasteboard<br>系统剪切板 场景：淘宝口令</li>
<li>UIDocumentInteractionController 系统级别，同设备上app之间的共享文档，以及文档预览，打印，发邮件和复制等</li>
<li>local socket<br>app1在本地端口port1234建立socket tcp的bind和listen，APP2在同一端口port1234 发起tcp的connect连接<br>场景：某个App1具有特殊的能力，比如能够跟硬件进行通信，在硬件上处理相关数据。而App2则没有这个能力，但是它能给App1提供相关的数据，这样APP2跟App1建立本地socket连接，传输数据到App1，然后App1在把数据传给硬件进行处理。<br>缺陷：需要后台运行，因此，系统在任意时刻只有一个app在前台运行，那么就需要通信的另一方具备后台运行权限，类似导航，音乐，蓝牙通信类</li>
</ul>
<h4 id="2-json解析及第三方库分析"><a href="#2-json解析及第三方库分析" class="headerlink" title="2.json解析及第三方库分析"></a>2.json解析及第三方库分析</h4><ul>
<li><p>苹果原生NSJSONSerialization<br>原生有一些解析未进行容错处理<br>//如：如何被解析的JSON数据如果既不是字典也不是数组（比如是NSString）, 那么就必须使用这</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSJSONReadingAllowFragments</span></div><div class="line">    <span class="built_in">NSData</span> *data = [test dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]</div><div class="line">    <span class="keyword">id</span> obj = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData: data options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
</li>
<li><p>SBJSON 、JSONModel<br><strong>字典转模型框架</strong>：<br>a.Mantle 需要继承自MTModel<br>b.JSONModel 需要继承自JSONModel<br>c.MJExtension 不需要继承，无代码侵入性（运行时）<br>注意点：json解析中，jsonkit解析空数据时会变成NSNull类型，既不是nil也是string。解决方案可以使用<a href="https://github.com/nicklockwood/NullSafe" target="_blank" rel="external">NullSafe</a><br>使用afnetwork时可以设置<code>self.removesKeysWithNullValues = YES;</code></p>
</li>
</ul>
<h4 id="3-AFNetwork3-x源码解析"><a href="#3-AFNetwork3-x源码解析" class="headerlink" title="3.AFNetwork3.x源码解析"></a>3.AFNetwork3.x源码解析</h4><p>源文件简而言之：AFHTTPSessionManager -&gt; 简单的HTTP请求封装<br>AFURLSessionManager -&gt; 网络通信核心，负责调配NSURLSession启动网络任务，设置session代理的转发、操作回调线程执行、组装参数及解析参数的调配等<br>AFNetworkReachabilityManager -&gt; 网络状态监控<br>AFSecurityPolicy -&gt; 网络安全策略<br>AFURLRequestSerialization/AFURLResponseSerialization -&gt; 数据序列化和反序列化<br>工具包AF UIKit -&gt; 图片下载及缓存策略，网络请求时状态栏上的菊花出现时机等<br>追问：self.operationQueue.maxConcurrentOperationCount = 1 AF3.x中操作队列并发线程数设置为1的目的？<br><a id="more"></a><br>1）众所周知，AF2.x所有的回调是在一条线程，这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。<br>2）因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。反而多task回调导致的多线程并发，平白浪费了部分性能。<br>而设置Queue的并发数为1，（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFUrlSessionManager的那些方法。）至少回调的事件，是不需要多线程并发的。回调没有了NSLock的等待时间，所以对时间并没有多大的影响。（注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程。）</p>
<p>做了什么：<br>1.各种请求方式request的拼接<br>2.对共用参数（session级别）和一些私用参数（task级别）的分离（<strong>代理转发的架构模式</strong>）<br>3.自定义的https认证处理<br>4.请求到数据后，做了各种数据格式的解析，支持自定义解析<br>5.成功和失败的回调处理<br>6.提供了UIKit的扩展（图片下载、缓存展示，菊花展示）</p>
<h4 id="4-野指针是什么，iOS-开发中什么情况下会有野指针？"><a href="#4-野指针是什么，iOS-开发中什么情况下会有野指针？" class="headerlink" title="4.野指针是什么，iOS 开发中什么情况下会有野指针？"></a>4.野指针是什么，iOS 开发中什么情况下会有野指针？</h4><p>野指针是不为 nil，但是指向已经被释放的内存的指针。<br>__unsafe_unretain或者assign的指针，对象释放后会出现野指针。<br>一般情况下oc使用了weak指针，在对象销毁时指针会置nil<br>Student *stu = [[Student alloc] init];<br>[stu setAge:10];<br>[stu release];这里已经释放内存<br>[stu setAge:10];—》报错</p>
<h4 id="5-简述runtime机制"><a href="#5-简述runtime机制" class="headerlink" title="5.简述runtime机制"></a>5.简述runtime机制</h4><p>OC是运行时语言，其中最重要的是消息机制，实现动态调用。<br>执行某个方法，实际是在运行时向对象发消息。<br>这里涉及到iOS中NSObject的对象模型，Class isa指针，指向metaclass也就是静态的Class。一般一个Obj对象中的isa会指向普通的Class，这个Class中存储普通成员变量和对 象方法（“-”开头的方法），普通Class中的isa指针指向静态Class，静态Class中存储static类型成员变量和类方法（“+”开头的方 法）</p>
<ul>
<li>编译器将代码[obj makeText];转化为<code>objc_msgSend(obj,@selector(makeText));</code></li>
<li>正常消息发送：在objc_msgSend函数中，首先通过obj对象的isa指针获取它对应的class，优先在class的cache查找message方法，如果找不到再到methodLists查找；如果在class中没有找到，则到super class查找，一旦找到就执行它的实现IMP</li>
<li>动态方法解析与消息转发：首先oc在运行时调用+resolveInstanceMethod:或+resolveClassMethod:方法，让你添加放到实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送过程。</li>
<li>快速转发：如果目标对象实现-forwardingTargetForSelector:方法，系统就会在运行时调用这个方法，只要这个方法返回的不是nil或self，也会重启消息发送的过程，把这消息转发给其他对象来处理，否则就会继续Normal Fowarding</li>
<li>正常转发：如果没有使用Fast Forwarding来消息转发，最后只有使用Normal Forwarding来进行消息转发。它首先调用methodSignatureForSelector：方法来获取函数的参数和返回值，如果返回为nil，程序会Crash掉，并抛出unrecognized selector sent to instance异常信息。如果返回一个函数签名，系统就会创建一个NSInvocation对象并调用-forwardInvocation:方法。<br>场景：1.为@dynamic实现方法 2.代理模式实现 3.多重继承实现<br><strong>Objective-C 提供了 NSProxy 类可以用来做动态代理</strong></li>
</ul>
<h4 id="6-runtime进阶理解—-category-和-class的载入过程"><a href="#6-runtime进阶理解—-category-和-class的载入过程" class="headerlink" title="6.runtime进阶理解—-category 和 class的载入过程"></a>6.runtime进阶理解—-category 和 class的载入过程</h4><p><a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">美团技术团队深入理解category</a></p>
<ul>
<li>使用场景：1.将类的实现分开在不同文件中 2.声明私有方法 3.模拟多继承 4.把framework的私有方法公开</li>
<li>对比extension：1.extension是编译期决议，是类的一部分，一般用来隐藏类的私有信息；必须有一个类的源码才能为类添加extension 2.而category是运行期决议，无法添加实例变量（运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局）</li>
<li>category的加载：1.category的方法没有“完全替换掉”原来类已经有的方法，如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA； 2.category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这就是category的方法会<strong>覆盖</strong>掉原来类的同名方法</li>
<li>category和load：1.附加category到类的工作先于+load方法的执行； 2.+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定； 3.虽然对于+load的执行顺序是这样，但是对于<strong>覆盖</strong>掉的方法，则会先找到最后一个编译的category里的对应方法。</li>
<li>category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</li>
<li>category可以配合关联对象实现给类添加实例变量；其中所有的关联对象都由AssociationsManager管理；runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</li>
</ul>
<h4 id="7-https单向验证和双向验证过程"><a href="#7-https单向验证和双向验证过程" class="headerlink" title="7.https单向验证和双向验证过程"></a>7.https单向验证和双向验证过程</h4><p>单向验证过程：整个https验证的流程了。简单总结一下：</p>
<p>就是用户发起请求，服务器响应后返回一个证书，证书中包含一些基本信息和公钥。<br>用户拿到证书后，去验证这个证书是否合法，不合法，则请求终止。<br>合法则生成一个随机数，作为对称加密的密钥，用服务器返回的公钥对这个随机数加密。然后返回给服务器。<br>服务器拿到加密后的随机数，利用私钥解密，然后再用解密后的随机数（对称密钥），把需要返回的数据加密，加密完成后数据传输给用户。<br>最后用户拿到加密的数据，用一开始的那个随机数（对称密钥），进行数据解密。整个单向验证过程完成。<br><a href="http://blog.csdn.net/duanbokan/article/details/50847612" target="_blank" rel="external">https单向验证和双向验证</a><br>SSL协议即用到了对称加密也用到了非对称加密(公钥加密)，在建立传输链路时，SSL首先对对称加密的密钥使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。</p>
<p><strong>对称加密 ：速度高，可加密内容较大，用来加密会话过程中的消息</strong><br><strong>公钥加密 ：加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥</strong></p>
<h4 id="8-串行vs并发-同步vs异步-队列vs线程"><a href="#8-串行vs并发-同步vs异步-队列vs线程" class="headerlink" title="8.串行vs并发 同步vs异步 队列vs线程"></a>8.串行vs并发 同步vs异步 队列vs线程</h4><p>参考文章：<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS并发编程之Operation Queues</a><br>串行与并发的主要区别：允许同时执行的任务数量</p>
<p>同步vs异步：主要区别在于<strong>是否等待操作执行完成，即是否阻塞当前线程</strong>。</p>
<p>队列vs线程：iOS中存在2种队列，串行队列和并发队列；串行队列中一次只能执行一个任务，并发队列则允许多个任务同时执行；iOS系统使用这些队列来进行任务调度，根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动管理。</p>
<blockquote>
<p>在其他许多语言中，为了提高应用的并发性，我们往往需要自行创建一个或多个额外的线程，并且手动地管理这些线程的生命周期，这本身就已经是一项非常具有挑战性的任务了。此外，对于一个应用来说，最优的线程个数会随着系统当前的负载和低层硬件的情况发生动态变化。因此，一个单独的应用想要实现一套正确的多线程解决方案就变成了一件几乎不可能完成的事情。而更糟糕的是，<strong>线程的同步机制</strong>大幅度地增加了应用的复杂性，并且还存在着不一定能够提高应用性能的风险。</p>
</blockquote>
<p>在iOS中，与直接创建线程的方式不同，我们只需定义好要调度的任务，然后让系统帮我们去执行这些任务就可以了。<br>当然在以下三种场景下，我们应该直接使用线程：</p>
<ul>
<li>用线程以外的其他方式都不能实现我们的特定任务</li>
<li>必须实时执行一个任务，因为虽然队列会尽可能快地执行我们提交的任务，但并不能保证实时性</li>
<li>需要对在后台执行的任务有更多的可预测行为</li>
</ul>
<p>gcd中注意项：<a href="http://blog.csdn.net/u013046795/article/details/47057585" target="_blank" rel="external">dispatch_barrier_async和dispatch_barrier_sync异同</a></p>
<blockquote>
<p>dispatch_barrier_sync和dispatch_barrier_async的共同点：<br>1、都会等待在它前面插入队列的任务（1、2、3）先执行完<br>2、都会等待他们自己的任务（0）执行完再执行后面的任务（4、5、6）<br>dispatch_barrier_sync和dispatch_barrier_async的不共同点：<br>在将任务插入到queue的时候，dispatch_barrier_sync需要等待自己的任务（0）结束之后才会继续程序，然后插入被写在它后面的任务（4、5、6），然后执行后面的任务<br>而dispatch_barrier_async将自己的任务（0）插入到queue之后，不会等待自己的任务结束，它会继续把后面的任务（4、5、6）插入到queue。<br>所以，dispatch_barrier_async的不等待（异步）特性体现在将任务插入队列的过程，它的等待特性体现在任务真正执行的过程。</p>
</blockquote>
<h4 id="9-dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁"><a href="#9-dispatch-barrier-async使用Barrier-Task方法Dispatch-Barrier解决多线程并发读写同一个资源发生死锁" class="headerlink" title="9.dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁"></a>9.dispatch_barrier_async使用Barrier Task方法Dispatch Barrier解决多线程并发读写同一个资源发生死锁</h4><p><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="external">GCD使用</a><br>Dispatch Barrier确保提交的闭包是指定队列中在特定时段唯一在执行的一个。在所有先于Dispatch Barrier的任务都完成的情况下这个闭包才开始执行。轮到这个闭包时barrier会执行这个闭包并且确保队列在此过程不会执行其它任务。闭包完成后队列恢复。需要注意dispatch_barrier_async只在自己创建的队列上有这种作用，在全局并发队列和串行队列上，效果和dispatch_sync一样</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建队列</span></div><div class="line"><span class="keyword">self</span>.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"><span class="comment">//改变setter</span></div><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSUInteger</span>)count forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">     key = [key <span class="keyword">copy</span>];</div><div class="line">     <span class="comment">//确保所有barrier都是async异步的</span></div><div class="line">     dispatch_barrier_async(<span class="keyword">self</span>.isolationQueue, ^()&#123;</div><div class="line">          <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">               [<span class="keyword">self</span>.counts removeObjectForKey:key];</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               <span class="keyword">self</span>.counts[key] = @(count);</div><div class="line">          &#125;</div><div class="line">     &#125;);</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)dispatchBarrierAsyncDemo &#123;</div><div class="line">    <span class="comment">//防止文件读写冲突，可以创建一个串行队列，操作都在这个队列中进行，没有更新数据读用并行，写用串行。</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> dataQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.dataqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 1"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 2"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="comment">//等待前面的都完成，在执行barrier后面的</span></div><div class="line">    dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write data 1"</span>);</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 3"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">dispatch_async</span>(dataQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read data 4"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-内存管理中，dealloc和release的区别是什么-block的实现机制"><a href="#10-内存管理中，dealloc和release的区别是什么-block的实现机制" class="headerlink" title="10.内存管理中，dealloc和release的区别是什么; block的实现机制"></a>10.内存管理中，dealloc和release的区别是什么; block的实现机制</h4><p>release 使对象的内存计数-1；dealloc释放的时候调用，清除</p>
<blockquote>
<p>僵尸对象：系统在回收对象时,可以不将其真的回收, 而是把它转化为僵尸对象,通过环境变量 NSZombieEnabled 可开启此功能系统会修改对象的 isa 指针,令其指向特殊的僵尸类, 从而使改对象变为僵尸对象.僵尸类能够相应所有的选择子, 相应方式为:打印一条包含消息内容及其接受者的消息,然后终止应用程序</p>
</blockquote>
<p>大量对象创建时循环遍历导致内存峰值，可以使用autoreleasepool<br><strong>以”自动释放池块”降低内存峰值</strong></p>
<blockquote>
<p>自动释放池排布在栈中, 对象收到 autorelease 消息后, 系统将其放入最顶端的池里要合理运用自动释放池, 可降低应用程序的内存封值<br>@autoreleasepool 这种新式写法能创建出更为轻便的自动释放池<br>常见的例子就是 下边的 加上@autoreleasepool应用程序在执行循环的时候内存峰值就会降低<br>如：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dataArr = [<span class="built_in">NSArray</span> array];</div><div class="line">    <span class="built_in">NSMutableArray</span> *personArrM = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *recode <span class="keyword">in</span> dataArr) &#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span>&#123;            </div><div class="line">            LLPerson *person = [[LLPerson alloc]initWithRecode:recode];</div><div class="line">            [personArrM addObject:person];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>block对象</code>：块本身也是对象,在存放块对象内存区域中, 首个变量是指向 Class 对象的指针,该指针叫做 isa, 其余内存里含有块对象正常运转所需的各种信息, 在内存布局中,最重要的就是 invoke 变量,这就是函数指针,指向块的实现代码, 函数原型只要要接受一个 void<em> 型的参数, 此参数代表块.刚才说过, <em>*块其实就是一种代替函数指针的语法结构</em></em> , 原来使用函数指针是需要用不透明的 void 指针来传递状态 而改用块之后, 则可以把原来用标准 C 语言特性所编写的代码封装成简明且易用的接口.</p>
<p><code>descriptor</code> 变量是指向结构体的指针, 每个块里都包含此结构体,其中声明了块对象的总体大小,还声明了 copy 和 dispose 这两个辅助函数所对象的函数指针, 辅助函数在拷贝及丢弃块对象时运行, 其中会执行一些操作, 比方说 前者要保留捕获的对象, 而后者则将之释放</p>
<p><strong>块还会把它所捕获的所有变量都拷贝一份, 这些拷贝放在 descriptor 变量后边,捕获了多少变量,就要占据多少内存空间, 请注意, 拷贝的并不是对象变量,而是指向这些对象的指针变量, invoke 函数为何需要把块对象作为参数传进来呢? 原因就在于,执行块的时候 要从内存中把这些捕获到的变量读出来</strong></p>
<p>相关阅读整理：<a href="http://www.imlifengfeng.com/blog/?p=457" target="_blank" rel="external">iOS Block详解</a></p>
<p><a href="https://www.wangjiawen.com/ios/ios-block-usage-and-implementation" target="_blank" rel="external">iOS Block用法和实现原理</a></p>
<h4 id="11-使用GCD实现高效代码加锁"><a href="#11-使用GCD实现高效代码加锁" class="headerlink" title="11.使用GCD实现高效代码加锁"></a>11.使用GCD实现高效代码加锁</h4><p>同步派发：create串行同步队列，读写操作安排在同一个队列中，保证数据同步（都使用dispatch_sync）<br>异步派发: 写操作异步操作（dispatch_async），弊端：比之前还慢，因为异步派发时需要拷贝block块</p>
<p><strong>优化：不使用串行队列，改为并发队列，并且使用栅栏（barrier）</strong></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(<span class="name">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)<span class="comment">;</span></div><div class="line">- (<span class="name">NSString</span> *)someString</div><div class="line">&#123;</div><div class="line">    __block NSString *localSomeString<span class="comment">;</span></div><div class="line">    dispatch_sync(<span class="name">_syncQueue</span>, ^&#123;</div><div class="line">        localSomeString = _someString<span class="comment">;</span></div><div class="line">    &#125;)<span class="comment">;</span></div><div class="line">    return localSomeString<span class="comment">;</span></div><div class="line">&#125;</div><div class="line">- (<span class="name">void</span>)setSomeString:(<span class="name">NSString</span> *)someString</div><div class="line">&#123;    </div><div class="line">    dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="12-KTVHTTPCache原理"><a href="#12-KTVHTTPCache原理" class="headerlink" title="12.KTVHTTPCache原理"></a>12.<a href="https://github.com/ChangbaDevs/KTVHTTPCache" target="_blank" rel="external">KTVHTTPCache</a>原理</h4><p>唱吧播放mp4文件，avplayer+KTVHTTPCache缓存播放</p>
<p><img src="https://camo.githubusercontent.com/130bd5189b7aa2e16c273874f8082c80cc72979f/687474703a2f2f6f786c366d787932742e626b742e636c6f7564646e2e636f6d2f6368616e6762612f4b54564854545043616368652d666c6f772d63686172742e6a706567" alt="KTVHTTPCache结构及工作流程图"></p>
<p><a href="https://github.com/ChangbaDevs/KTVHTTPCache#%E4%B8%8B%E9%9D%A2%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="external">工作流程描述</a></p>
<p>值得注意的几个点：<br>1.使用<a href="https://github.com/robbiehanson/CocoaHTTPServer" target="_blank" rel="external">CocoaHTTPServer</a>设置本地http代理服务器，hook到播放器资源加载请求<br>2.模块化设置，各个类职责单一明显<br>3.缓存策略中的<strong>分片加载数据</strong>，区分本地数据和网络数据，最小化网络下载请求<br>4.对于锁屏后server socket失效的处理方式：做URL映射时先去ping一下本地的server，如果ping不通，则重启本地server（<strong>注：这里ping本地server的逻辑实现可以看看，使用NSCondition和NSURLSessionDataTask配合调用实现</strong>）</p>
<h4 id="13-显示动画-uiview动画-与隐示动画（calayer动画）"><a href="#13-显示动画-uiview动画-与隐示动画（calayer动画）" class="headerlink" title="13.显示动画(uiview动画)与隐示动画（calayer动画）"></a>13.显示动画(uiview动画)与隐示动画（calayer动画）</h4><ul>
<li>UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画。</li>
<li>对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。</li>
</ul>
<p>你改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值；这一切都是默认的行为，你不需要做额外的操作，这就是隐式动画。<br>隐式动画的原因是我们没有指定动画的类型，只是改变了一个属性，然后Core Animation自己决定怎样去做动画，何时去做动画。</p>
<blockquote>
<p>系统什么时候处理隐式动画：Core Animation在每个run loop周期中自动开始一次新的事务，任何在一次run loop循环中的属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>
</blockquote>
<p><strong>要想理解隐式动画，需要清楚几个概念：事务（CATransaction）、完成块（+setCompletionlock:）、图层行为（actions）以及呈现与模型</strong></p>
<p>呈现与模型：mvc模式，core animation相当于控制器，负责根据图层行为和事务的设置去不断的更新屏幕上这些属性的状态；calayer相当于模型，连接用户界面的虚构的类，存储了视图如何显示和动画的数据模型；呈现图层：<strong>模型图层的复制，呈现图层上的属性值代表了当前屏幕显示的外观效果的属性的值，可以使用-presentationLayer方法来获取当前屏幕上属性的真正显示的值。</strong></p>
<p>理解离屏渲染：</p>
<blockquote>
<p>当layer属性的混合体被指定在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤醒。layer必须在被显示之前在一个屏幕外上下文中被渲染。<br>layer的以下属性将会触发屏幕外绘制：1.圆角（当和maskToBounds一起使用时） 2.图层蒙板 3.阴影</p>
</blockquote>
<h4 id="14-内联函数"><a href="#14-内联函数" class="headerlink" title="14.内联函数"></a>14.内联函数</h4><p>1.inline函数避免了普通函数的,在汇编时必须调用call的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快;<br>2.集成了宏的优点,使用时直接用代码替换(像宏一样);<br>3.避免了宏的缺点:需要预编译.因为inline内联函数也是函数,不需要预编译.<br>4.编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。<br>5.可以使用所在类的保护成员及私有成员<br><a href="http://www.jianshu.com/p/d557b0831c6a" target="_blank" rel="external">inline</a><br><a href="https://www.bbsmax.com/A/A2dmYLK4de/" target="_blank" rel="external">内联函数在iOS中的使用</a></p>
<ul>
<li>使用inline函数完全取代表达式形式的宏定义</li>
<li>在内联函数内不允许用循环语句和 开关语句</li>
</ul>
<blockquote>
<p>如果方法的调用频率很大，那么可以考虑使用内联函数来提高性能</p>
</blockquote>
<p>参考文章：</p>
<ul>
<li><a href="http://www.bijishequ.com/detail/565351?p=" target="_blank" rel="external">《Effective Objective-C重读校验自己的知识体系》</a></li>
<li><a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="external">深入剖析iOS性能优化</a></li>
<li><a href="http://www.jianshu.com/p/35dd92bcfe8c" target="_blank" rel="external">iOS各种线程锁的简单介绍</a></li>
<li><a href="http://www.jianshu.com/p/4ffeb1ba3046" target="_blank" rel="external">AFNetworking究竟做了什么</a></li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/chapter7/layer-actions.html" target="_blank" rel="external">iOS核心动画高级技巧之图层行为</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-APP之间通信方式有哪些&quot;&gt;&lt;a href=&quot;#1-APP之间通信方式有哪些&quot; class=&quot;headerlink&quot; title=&quot;1.APP之间通信方式有哪些&quot;&gt;&lt;/a&gt;1.APP之间通信方式有哪些&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;URL Scheme&lt;br&gt;（在info.plist中配置LSApplicationQueriesSchemes，指定目标app的scheme，然后在目标app的info.plist中配置好URL types）场景：分享，支付等&lt;/li&gt;
&lt;li&gt;Keychain&lt;br&gt;本质是sqlite数据库，独立每个app的沙盒之外，即使删除app，keychain中的信息还存在&lt;br&gt;特点：不同app之间需要通过keychain access groups才行，同一个teamID&lt;br&gt;场景：用户登录信息保存，同一平台上多个app之间实现统一账户登录&lt;/li&gt;
&lt;li&gt;UIPasteboard&lt;br&gt;系统剪切板 场景：淘宝口令&lt;/li&gt;
&lt;li&gt;UIDocumentInteractionController 系统级别，同设备上app之间的共享文档，以及文档预览，打印，发邮件和复制等&lt;/li&gt;
&lt;li&gt;local socket&lt;br&gt;app1在本地端口port1234建立socket tcp的bind和listen，APP2在同一端口port1234 发起tcp的connect连接&lt;br&gt;场景：某个App1具有特殊的能力，比如能够跟硬件进行通信，在硬件上处理相关数据。而App2则没有这个能力，但是它能给App1提供相关的数据，这样APP2跟App1建立本地socket连接，传输数据到App1，然后App1在把数据传给硬件进行处理。&lt;br&gt;缺陷：需要后台运行，因此，系统在任意时刻只有一个app在前台运行，那么就需要通信的另一方具备后台运行权限，类似导航，音乐，蓝牙通信类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-json解析及第三方库分析&quot;&gt;&lt;a href=&quot;#2-json解析及第三方库分析&quot; class=&quot;headerlink&quot; title=&quot;2.json解析及第三方库分析&quot;&gt;&lt;/a&gt;2.json解析及第三方库分析&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;苹果原生NSJSONSerialization&lt;br&gt;原生有一些解析未进行容错处理&lt;br&gt;//如：如何被解析的JSON数据如果既不是字典也不是数组（比如是NSString）, 那么就必须使用这&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSJSONReadingAllowFragments&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [test dataUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSJSONSerialization&lt;/span&gt; JSONObjectWithData: data options:&lt;span class=&quot;built_in&quot;&gt;NSJSONReadingAllowFragments&lt;/span&gt; error:&lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SBJSON 、JSONModel&lt;br&gt;&lt;strong&gt;字典转模型框架&lt;/strong&gt;：&lt;br&gt;a.Mantle 需要继承自MTModel&lt;br&gt;b.JSONModel 需要继承自JSONModel&lt;br&gt;c.MJExtension 不需要继承，无代码侵入性（运行时）&lt;br&gt;注意点：json解析中，jsonkit解析空数据时会变成NSNull类型，既不是nil也是string。解决方案可以使用&lt;a href=&quot;https://github.com/nicklockwood/NullSafe&quot;&gt;NullSafe&lt;/a&gt;&lt;br&gt;使用afnetwork时可以设置&lt;code&gt;self.removesKeysWithNullValues = YES;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;3-AFNetwork3-x源码解析&quot;&gt;&lt;a href=&quot;#3-AFNetwork3-x源码解析&quot; class=&quot;headerlink&quot; title=&quot;3.AFNetwork3.x源码解析&quot;&gt;&lt;/a&gt;3.AFNetwork3.x源码解析&lt;/h4&gt;&lt;p&gt;源文件简而言之：AFHTTPSessionManager -&amp;gt; 简单的HTTP请求封装&lt;br&gt;AFURLSessionManager -&amp;gt; 网络通信核心，负责调配NSURLSession启动网络任务，设置session代理的转发、操作回调线程执行、组装参数及解析参数的调配等&lt;br&gt;AFNetworkReachabilityManager -&amp;gt; 网络状态监控&lt;br&gt;AFSecurityPolicy -&amp;gt; 网络安全策略&lt;br&gt;AFURLRequestSerialization/AFURLResponseSerialization -&amp;gt; 数据序列化和反序列化&lt;br&gt;工具包AF UIKit -&amp;gt; 图片下载及缓存策略，网络请求时状态栏上的菊花出现时机等&lt;br&gt;追问：self.operationQueue.maxConcurrentOperationCount = 1 AF3.x中操作队列并发线程数设置为1的目的？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GCP Shadowsocks</title>
    <link href="https://www.devhua.com/2017/11/24/gcp-shadowsocks/"/>
    <id>https://www.devhua.com/2017/11/24/gcp-shadowsocks/</id>
    <published>2017-11-24T06:50:10.000Z</published>
    <updated>2017-12-20T10:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一键式通过GCP自建科学上网服务"><a href="#一键式通过GCP自建科学上网服务" class="headerlink" title="一键式通过GCP自建科学上网服务"></a>一键式通过GCP自建科学上网服务</h2><h3 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h3><p>需要准备一张visa卡（本人使用的是招行visa信用卡），在google cloud platform注册账号信息</p>
<blockquote>
<p>说明：GCP新用户有免费一年的使用时长，配额是300美金</p>
</blockquote>
<a id="more"></a>
<h3 id="2-在GCP的控制台上创建Compute-Engine的VM实例"><a href="#2-在GCP的控制台上创建Compute-Engine的VM实例" class="headerlink" title="2.在GCP的控制台上创建Compute Engine的VM实例"></a>2.在GCP的控制台上创建Compute Engine的VM实例</h3><h4 id="如图创建"><a href="#如图创建" class="headerlink" title="如图创建"></a>如图创建<img src="/2017/11/24/gcp-shadowsocks/1511493290168.png" alt="Alt text"></h4><p>具体机器配置可以根据自己使用情况来定<br>博主选的是<a href="https://zh.wikipedia.org/wiki/Debian" target="_blank" rel="external">Debain系统</a> 1.7G内存</p>
<h4 id="配置ssh远程登录登录（gcp自动会根据你google账号配置网页端ssh登录方式的信息）"><a href="#配置ssh远程登录登录（gcp自动会根据你google账号配置网页端ssh登录方式的信息）" class="headerlink" title="配置ssh远程登录登录（gcp自动会根据你google账号配置网页端ssh登录方式的信息）"></a>配置ssh远程登录登录（gcp自动会根据你google账号配置<strong>网页端ssh登录方式</strong>的信息）</h4><p>使用自己电脑登录还需要将电脑的ssh key添加到Compute Engine -&gt; 元数据 -&gt; ssh密钥 中</p>
<h3 id="3-远程登录google云服务器进行配置"><a href="#3-远程登录google云服务器进行配置" class="headerlink" title="3.远程登录google云服务器进行配置"></a>3.远程登录google云服务器进行配置</h3><h4 id="登录完成后执行脚（sudo-执行）"><a href="#登录完成后执行脚（sudo-执行）" class="headerlink" title="登录完成后执行脚（sudo 执行）"></a>登录完成后执行脚（sudo 执行）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh</div></pre></td></tr></table></figure>
<p>如图：<img src="/2017/11/24/gcp-shadowsocks/1511504467509.png" alt="Alt text"><br>根据脚本提示安装ShadowsocksR并设置用户信息，包含用户名密码，端口号等<br>加密：rc4-md5<br>协议：origin<br>混淆：plain</p>
<h4 id="启动BBR-TCP加速使你的上网体验更加流畅"><a href="#启动BBR-TCP加速使你的上网体验更加流畅" class="headerlink" title="启动BBR TCP加速使你的上网体验更加流畅"></a>启动BBR TCP加速使你的上网体验更加流畅</h4><blockquote>
<p>BBR (Bottleneck Bandwidth and RTT)是由google工程师编写的新的 TCP 拥塞控制算法，目的是要尽量跑满带宽, 并且尽量不要有排队的情况。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -N --no-check-certificate https://softs.fun/Bash/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; bash bbr.sh</div></pre></td></tr></table></figure>
<p>使用<code>bash /home/xxx/bbr.sh status</code> 检查bbr开启状态</p>
<h3 id="VPC网络配置"><a href="#VPC网络配置" class="headerlink" title="VPC网络配置"></a>VPC网络配置</h3><p>在GCP控制台的VPC网络设置中配置防火墙规则<br>如图<img src="/2017/11/24/gcp-shadowsocks/1511496865202.png" alt="Alt text"><br><img src="/2017/11/24/gcp-shadowsocks/1511496870752.png" alt="Alt text"></p>
<p>至此科学上网服务已经搭建完成，mac端安装ss客户端就可以了，iOS手机端推荐个美区的app -&gt; <code>Potatso Lite</code></p>
<p><strong>GCP的服务还包含很多其他内容，可以自建一些服务、观察服务访问流量、大数据、机器学习相关。</strong></p>
<p>参考链接：<a href="https://jasper-1024.github.io/2016/06/26/VPS%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97/" target="_blank" rel="external">科学上网教程系列</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一键式通过GCP自建科学上网服务&quot;&gt;&lt;a href=&quot;#一键式通过GCP自建科学上网服务&quot; class=&quot;headerlink&quot; title=&quot;一键式通过GCP自建科学上网服务&quot;&gt;&lt;/a&gt;一键式通过GCP自建科学上网服务&lt;/h2&gt;&lt;h3 id=&quot;1-前期准备&quot;&gt;&lt;a href=&quot;#1-前期准备&quot; class=&quot;headerlink&quot; title=&quot;1.前期准备&quot;&gt;&lt;/a&gt;1.前期准备&lt;/h3&gt;&lt;p&gt;需要准备一张visa卡（本人使用的是招行visa信用卡），在google cloud platform注册账号信息&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：GCP新用户有免费一年的使用时长，配额是300美金&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Network" scheme="https://www.devhua.com/categories/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>WKWebview tips</title>
    <link href="https://www.devhua.com/2017/04/24/iOS-WKWebview-Tips/"/>
    <id>https://www.devhua.com/2017/04/24/iOS-WKWebview-Tips/</id>
    <published>2017-04-24T09:38:04.000Z</published>
    <updated>2017-12-20T10:17:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WKWebview-踩坑之旅（正在更新…）"><a href="#WKWebview-踩坑之旅（正在更新…）" class="headerlink" title="WKWebview 踩坑之旅（正在更新…）"></a>WKWebview 踩坑之旅（正在更新…）</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>关于iOS 8后出来的WKWebview的简介，及对比UIWebview的优势 就不再做赘述了。可以参考<br><a href="http://nshipster.cn/wkwebkit/" target="_blank" rel="external">nshipster介绍WKWebview</a><br>学习WKWebview需研究<a href="https://github.com/WebKit/webkit" target="_blank" rel="external">源码</a>，可以调试下miniBrowser项目</p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在WKWebview出来这几年后，老项目一直未迁移到wkwebview，尽管我们知道它有着60 fps滚动刷新率，内存占用少，和safari相同的JavaScript引擎等优势，但由于其本身的不完善和一些坑点以及迁移的工作量等问题，一直未深入研究迁移方案。<br>但多个UIWebview浏览的内存暴涨导致容易crash一直是块心病。于是还是尝试迁移到wkwebview，便有了一段<strong>踩坑之旅</strong>。</p>
<a id="more"></a>
<h3 id="WKWebview使用注意点"><a href="#WKWebview使用注意点" class="headerlink" title="WKWebview使用注意点"></a>WKWebview使用注意点</h3><p>网上也已经有不少使用注意点的总结文章，在此先贴出了，然后讲些自己遇到的问题和处理方案。<br><a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a><br><a href="https://github.com/ShingoFukuyama/WKWebViewTips" target="_blank" rel="external">WKWebviewTips</a></p>
<h4 id="1-加载本地html注意区分系统版本"><a href="#1-加载本地html注意区分系统版本" class="headerlink" title="1. 加载本地html注意区分系统版本"></a>1. 加载本地html注意区分系统版本</h4><p>iOS9及以上版本可以使用<br><code>[self.webview loadRequest:request]</code></p>
<p><strong>本地资源生成的request在iOS8下无法加载</strong><br>iOS8下加载本地文件: <code>[self.webview loadHTMLString:str]</code><br> <a href="http://stackoverflow.com/questions/27803341/swift-wkwebview-loading-local-file-not-working-on-a-device" target="_blank" rel="external">http://stackoverflow.com/questions/27803341/swift-wkwebview-loading-local-file-not-working-on-a-device</a></p>
<h4 id="2-跨域跳转处理"><a href="#2-跨域跳转处理" class="headerlink" title="2.跨域跳转处理"></a>2.跨域跳转处理</h4><p><code>- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler</code><br>此代理中对于一些<code>navigationAction.navigationType</code>跳转类型判断需要注意自己处理。不然容易出现点击页面链接无响应。</p>
<h4 id="3-共享cookie问题"><a href="#3-共享cookie问题" class="headerlink" title="3.共享cookie问题"></a>3.共享cookie问题</h4><p>如果有同时开多个网页的需求，这就需要注意共享cookie了。由于本身WKWebview中使用到了WKProcessPool，导致多个wkwebview间无法共享cookie。查看<a href="https://github.com/mozilla-mobile/firefox-ios/blob/master/Client/Frontend/Browser/TabManager.swift" target="_blank" rel="external">firefox源码</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A WKWebViewConfiguration used for normal tabs</span></div><div class="line">    lazy fileprivate var configuration: <span class="built_in">WKWebViewConfiguration</span> = &#123;</div><div class="line">        let configuration = <span class="built_in">WKWebViewConfiguration</span>()</div><div class="line">        configuration.processPool = <span class="built_in">WKProcessPool</span>()</div><div class="line">        configuration.preferences.javaScriptCanOpenWindowsAutomatically = !(<span class="keyword">self</span>.prefs.boolForKey(<span class="string">"blockPopups"</span>) ?? <span class="literal">true</span>)</div><div class="line">        <span class="keyword">return</span> configuration</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    <span class="comment">// A WKWebViewConfiguration used for private mode tabs</span></div><div class="line">    lazy fileprivate var privateConfiguration: <span class="built_in">WKWebViewConfiguration</span> = &#123;</div><div class="line">        let configuration = <span class="built_in">WKWebViewConfiguration</span>()</div><div class="line">        configuration.processPool = <span class="built_in">WKProcessPool</span>()</div><div class="line">        configuration.preferences.javaScriptCanOpenWindowsAutomatically = !(<span class="keyword">self</span>.prefs.boolForKey(<span class="string">"blockPopups"</span>) ?? <span class="literal">true</span>)</div><div class="line">        configuration.websiteDataStore = <span class="built_in">WKWebsiteDataStore</span>.nonPersistent()</div><div class="line">        <span class="keyword">return</span> configuration</div><div class="line">    &#125;()</div></pre></td></tr></table></figure>
<p>以上代码是firefox在正常模式及隐私模式下创建的configuration.<br>当然，在app被kill掉后再启动又会被重置，导致pool中的cookie数据丢失。如果不是做浏览器，而是自身app与服务器打交道，可以考虑把cookie信息在请求前手动加上header中。<br>参考：<br><a href="http://stackoverflow.com/questions/39772007/wkwebview-persistent-storage-of-cookies" target="_blank" rel="external">http://stackoverflow.com/questions/39772007/wkwebview-persistent-storage-of-cookies</a></p>
<p><a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview" target="_blank" rel="external">http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview</a></p>
<p><a href="http://stackoverflow.com/questions/33156567/getting-all-cookies-from-wkwebview" target="_blank" rel="external">http://stackoverflow.com/questions/33156567/getting-all-cookies-from-wkwebview</a></p>
<h4 id="4-部分特殊页面点击链接事件失效"><a href="#4-部分特殊页面点击链接事件失效" class="headerlink" title="4.部分特殊页面点击链接事件失效"></a>4.部分特殊页面点击链接事件失效</h4><p>在浏览部分邮箱页面（）在新标签页打开 ( wkwebview )时<br>//例如：target = “_blank”</p>
<p><code>&lt;a href=&quot;https://m.baidu.com/?tn=&amp;amp;from=1018225b&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot; class=&quot;&quot;&gt;https://m.baidu.com/?tn=&amp;amp;from=1018225b&lt;/a&gt;</code></p>
<p>点击链接后，在这个<code>- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures</code>代理中收到的<code>request.url</code>为空，无法获取到正确请求。<br>这个问题在firefox上也有且未解决，然而Safari上都是正常的（苹果还是老奸巨猾啊。。）<br>参考: <a href="http://swiftgazelle.com/2015/08/wkwebview-target_blank-quirks/" target="_blank" rel="external">WKWebview-target-blank-quirks</a><br>当然UIWebview也有这样的问题，莫名其妙在CreateNewWebview代理中获取到的request为空，不过，UIWebview可以通过一些私有方式，很方便的获取到网页内部信息。</p>
<h4 id="5-页面跳转后再返回不会执行script和Ajax"><a href="#5-页面跳转后再返回不会执行script和Ajax" class="headerlink" title="5.页面跳转后再返回不会执行script和Ajax"></a>5.页面跳转后再返回不会执行script和Ajax</h4><p><strong>从页面a进入页面b再返回页面a后不会重新执行script和Ajax，也不会触发页面reload，此部分情况需要针对实际场景做处理，手动reload。</strong></p>
<h4 id="6-数据清除"><a href="#6-数据清除" class="headerlink" title="6.数据清除"></a>6.数据清除</h4><p>iOS 8下<code>WKWebsiteDataStore</code>还不支持，因此需要手动删除Cookies，Caches，Webkit文件夹（注意数据保存的路径问题）<br>iOS 9虽然有<code>WKWebsiteDataStore</code>接口，但实际使用起来会有概率性crash情况。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSSet</span> *websiteDataTypes</div><div class="line">= [<span class="built_in">NSSet</span> setWithArray:@[</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeDiskCache</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeOfflineWebApplicationCache</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeMemoryCache</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeLocalStorage</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeCookies</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeSessionStorage</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeIndexedDBDatabases</span>,</div><div class="line">                        <span class="built_in">WKWebsiteDataTypeWebSQLDatabases</span></div><div class="line">                        ]];</div><div class="line"><span class="comment">//// All kinds of data</span></div><div class="line"><span class="comment">//NSSet *websiteDataTypes = [WKWebsiteDataStore allWebsiteDataTypes];</span></div><div class="line"><span class="comment">//// Date from</span></div><div class="line"><span class="built_in">NSDate</span> *dateFrom = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">0</span>];</div><div class="line"><span class="comment">//// Execute</span></div><div class="line">[[<span class="built_in">WKWebsiteDataStore</span> defaultDataStore] removeDataOfTypes:websiteDataTypes modifiedSince:dateFrom completionHandler:^&#123;</div><div class="line">   <span class="comment">// Done</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>因此建议直接根据路径删除文件夹（iOS 8和iOS 9后数据保存的路径不一致，需要判断）</strong></p>
<h4 id="7-横竖屏切换调整wkwebview视图"><a href="#7-横竖屏切换调整wkwebview视图" class="headerlink" title="7.横竖屏切换调整wkwebview视图"></a>7.横竖屏切换调整wkwebview视图</h4><h4 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h4><h3 id="wkwebview刷新机制"><a href="#wkwebview刷新机制" class="headerlink" title="wkwebview刷新机制"></a>wkwebview刷新机制</h3><p>在一些低端机型上，滑动webview时明显就一段一段的白屏出现，跟UIWebview表现差远了。这引起了兴趣，查看并研究了下源码，发现wkwebview并不是跟uiwebview一样渲染所有网络数据，而是一屏一屏的渲染，也是这样才有了内存占用少的优势。也有一篇源码的文章推荐下<a href="http://www.jianshu.com/p/1d739e2e7ed2" target="_blank" rel="external">WKWebView刷新机制小探</a></p>
<blockquote>
<p>WKContentView就是WKWebView内容渲染的容器。在Reveal的树状图上面可以看到，渲染页面中，展示在页面上的渲染单元是WKCompositingView，WKCompositingView可以嵌套WKCompositingView。其中的一个WKCompositingView实例，将包含多个WKCompositingView子实例。类似于UITableView的重用机制，多个WKCompositingView的父View就相当于UITableView，WKCompositingView就相当于UITableViewCell，只展示可视区域的内容，达到性能优化的目的。</p>
<p>一个WKWebView加载的web内容，切割成多个WKCompositingView，单个WKCompositingView重用单元的面积是375x512点。</p>
</blockquote>
<p>从源码入手确实可以看到很多实现细节，但真正想要想像UIWebview一样hook掉很多系统属性和方法是不可能的，只能说苹果做的真绝。。</p>
<p>理解了这个刷新机制后，在做一些类似新闻类，有多个wkwebview当做uiview add到tableview上，即使竖向滚动也可以绑定wkwebview的scrollview的刷新渲染了。（<code>[WKWebView _updateVisibleContentRects]</code>）<br>推荐的文章最后说使用以下3个方法解决白屏问题：</p>
<ul>
<li>用KVO方法监听UITableView的contnetOffset属性，contentOffset发生变化也就是说UITableView发生滚动，调用WKWebView实例的_updateVisibleContentRects，刷新需要渲染的内容</li>
<li>UITableView是继承自UIScrollView的，在代码中实现UIScrollView的delegate，在delegate实现中手动调用WKWebView实例等UIScrollViewDelegate的方法，原理和第一种方法一样</li>
<li>使用CADisplayLink类，在CADisplayLink的回调方法里面调用WKWebView实例的_updateVisibleContentRects即可</li>
</ul>
<p>真正操作时你会发现，在快速滑动UITableView时，代理暴露出来的点跨度很大，完全不连贯，导致刷新内部webview的内容不及时。<strong>因此推荐使用CADisplaylink类，利用屏幕刷新机制去触发wkwebview实例的刷新。</strong></p>
<h3 id="wkwebview致命缺陷-NSURLProtocol问题"><a href="#wkwebview致命缺陷-NSURLProtocol问题" class="headerlink" title="wkwebview致命缺陷 - NSURLProtocol问题"></a>wkwebview致命缺陷 - NSURLProtocol问题</h3><p>（待更新）</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;WKWebview-踩坑之旅（正在更新…）&quot;&gt;&lt;a href=&quot;#WKWebview-踩坑之旅（正在更新…）&quot; class=&quot;headerlink&quot; title=&quot;WKWebview 踩坑之旅（正在更新…）&quot;&gt;&lt;/a&gt;WKWebview 踩坑之旅（正在更新…）&lt;/h1&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;关于iOS 8后出来的WKWebview的简介，及对比UIWebview的优势 就不再做赘述了。可以参考&lt;br&gt;&lt;a href=&quot;http://nshipster.cn/wkwebkit/&quot;&gt;nshipster介绍WKWebview&lt;/a&gt;&lt;br&gt;学习WKWebview需研究&lt;a href=&quot;https://github.com/WebKit/webkit&quot;&gt;源码&lt;/a&gt;，可以调试下miniBrowser项目&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在WKWebview出来这几年后，老项目一直未迁移到wkwebview，尽管我们知道它有着60 fps滚动刷新率，内存占用少，和safari相同的JavaScript引擎等优势，但由于其本身的不完善和一些坑点以及迁移的工作量等问题，一直未深入研究迁移方案。&lt;br&gt;但多个UIWebview浏览的内存暴涨导致容易crash一直是块心病。于是还是尝试迁移到wkwebview，便有了一段&lt;strong&gt;踩坑之旅&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS应用脱壳与重签名</title>
    <link href="https://www.devhua.com/2016/11/05/iOS%E5%BA%94%E7%94%A8%E8%84%B1%E5%A3%B3%E5%92%8C%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    <id>https://www.devhua.com/2016/11/05/iOS应用脱壳和重签名/</id>
    <published>2016-11-05T02:28:40.000Z</published>
    <updated>2017-04-24T05:54:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期干货"><a href="#前期干货" class="headerlink" title="前期干货"></a>前期干货</h2><p><a href="http://www.mottoin.com/92530.html" target="_blank" rel="external">iOS破壳</a></p>
<p><a href="http://blog.csdn.net/oyzhx/article/details/38339129" target="_blank" rel="external">用dumpdecrypted给App砸壳</a></p>
<p><a href="http://www.cnblogs.com/ludashi/p/5725743.html" target="_blank" rel="external">iOS逆向工程之给App脱壳</a></p>
<p><a href="https://testerhome.com/topics/4558" target="_blank" rel="external">给微信加 hook 尝试记录</a></p>
<p><a href="http://www.jianshu.com/p/189afbe3b429" target="_blank" rel="external">一步一步实现iOS微信自动抢红包(非越狱)
</a></p>
<h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><p>hopper：对脱壳app进行反汇编、反编译 可以分析app二进制文件<br>dumpdecrypted：用于脱壳<br>class-dump：对脱壳app 导出头文件</p>
<p>越狱设备一台（当时是6s Plus ,ios9.2）<br>越狱后安装有 cydia ，通过cydia安装openSSH，可以通过网段连接到mac</p>
<a id="more"></a>
<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>步骤：</p>
<ul>
<li>下载 dumpdecrypted源码，然后在dumpdecrypted目录下make，生成dumpdecrypted.dylib文件</li>
<li>电脑连接越狱设备（同一网段）：ssh root@192.168.13.230<br>root@192.168.13.230’s password:<br>openSSH的连接默认密码为:alpine。</li>
<li>电脑连上手机后查询当前运行进程 ps -e | grep /var/mobile<br>此处直接打印出手机安装app的进程</li>
<li>将电脑中make生成的dumpdecrypted.dylib文件 使用 scp 指令复制到 手机的/var/tmp/ 目录</li>
<li>脱壳指令：6sPlus:/var/tmp root# DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/mobile/Containers/Bundle/Application/6E1CC0B2-4DB7-4F37-B715-FAA317EEC469/WeChat.app/WeChat<br>此指令只能在当前/var/tmp/ 目录下执行</li>
<li>完成后在手机/var/tmp/目录下ls查看，得到WeChat.decrypted文件（目标脱壳文件）</li>
<li>将脱壳文件使用scp拷贝到电脑：scp root@192.168.13.230:/var/tmp/WeChat.decrypted /Users/xxx/Desktop</li>
<li>使用指令 otool -l WeChat.decrypted | grep crypt  (查看是否脱壳)<br>使用指令class-dump -S -s -H WeChat.decrypted -o ./Headers（dump出头文件）</li>
</ul>
<p>过程中的坑点：</p>
<p>架构问题：这次越狱设备是arm64架构的，dumpdecrypted编译出的是支持arm64，还有class-dump指令也是直接arm64.如果你越狱设备是armv7的则需要修改配置</p>
<p>iOS9.2越狱设备：在网上查资料，好多说是要将dumpdecrypted.dylib文件拷贝到 目标app的document目录下，可是越狱设备安装了很多app，完全不好确定目标app的document目录，本来可以使用Cycript注入目标进程中（cycript -p WeChat），然后执行[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask][0] 获取目标进程的Document目录，然后复制文件过去就好。可是实施发现，iOS9.2越狱设备下使用Cycript指令后终端一直卡死，无显示。（设备确认安装了Cycript，应该是Cycript插件不支持iOS9.2），这样就无法获取目标app的document目录！好在发现直接把dumpdecrypted.dylib放在手机的/var/tmp/目录下，执行脱壳指令也是可行的！</p>
<h2 id="重签名app"><a href="#重签名app" class="headerlink" title="重签名app"></a>重签名app</h2><p><a href="http://forums.macnn.com/79/developer-center/355720/how-re-sign-apples-applications-once/" target="_blank" rel="external">《How to re-sign Apple’s applications once they’ve been modified》</a></p>
<p><a href="http://www.ifun.cc/blog/2014/02/22/ios-appzhong-xin-qian-ming-fang-fa-jie-shao/" target="_blank" rel="external">中文简版步骤</a></p>
<p>步骤：</p>
<ul>
<li>查看有效的证书 : security find-identity -v -p codesigning</li>
<li>检查目标app签名情况：codesign -dvvv EmojiKeyboard.app</li>
<li>删除ipa中之前的签名文件:rm -rf Payload/*.app/_CodeSignature/</li>
<li>拷贝新的provision profile替换旧的embedded.mobileprovision（这个provision profile需要是distribution provision，可以找之前项目的）  cp 123.mobileprovision Payload/*.app/embedded.mobileprovision</li>
<li>重签名：codesign -f -s (name of certificate) /path/to/application</li>
</ul>
<p>例如：<br>➜  Payload codesign -f -s “iPhone Developer: xxx@xxx.com (9283B989BB)” xxx.app<br>xxx.app: replacing existing signature<br>➜  Payload codesign -dvvv xxx.app</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前期干货&quot;&gt;&lt;a href=&quot;#前期干货&quot; class=&quot;headerlink&quot; title=&quot;前期干货&quot;&gt;&lt;/a&gt;前期干货&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.mottoin.com/92530.html&quot;&gt;iOS破壳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/oyzhx/article/details/38339129&quot;&gt;用dumpdecrypted给App砸壳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/ludashi/p/5725743.html&quot;&gt;iOS逆向工程之给App脱壳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://testerhome.com/topics/4558&quot;&gt;给微信加 hook 尝试记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/189afbe3b429&quot;&gt;一步一步实现iOS微信自动抢红包(非越狱)
&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;工具：&quot;&gt;&lt;a href=&quot;#工具：&quot; class=&quot;headerlink&quot; title=&quot;工具：&quot;&gt;&lt;/a&gt;工具：&lt;/h3&gt;&lt;p&gt;hopper：对脱壳app进行反汇编、反编译 可以分析app二进制文件&lt;br&gt;dumpdecrypted：用于脱壳&lt;br&gt;class-dump：对脱壳app 导出头文件&lt;/p&gt;
&lt;p&gt;越狱设备一台（当时是6s Plus ,ios9.2）&lt;br&gt;越狱后安装有 cydia ，通过cydia安装openSSH，可以通过网段连接到mac&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 网络层架构设计与实现</title>
    <link href="https://www.devhua.com/2016/03/20/iOS-Network-design/"/>
    <id>https://www.devhua.com/2016/03/20/iOS-Network-design/</id>
    <published>2016-03-20T12:35:52.000Z</published>
    <updated>2018-01-08T16:09:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>客户端网络层交互流程:</p>
<ul>
<li>获取参数，统一配置</li>
<li>根据API配置公共参数</li>
<li>构造网络请求</li>
<li>发送网络请求</li>
<li>获取返回结果</li>
<li>展示数据</li>
</ul>
<p>注：此处还应该有个 <code>数据持久化</code> 流程，因项目业务层逻辑及存储方案各不相同，本篇中不展开介绍<br>另：本篇幅中暂时只涉及到HTTP的请求，TCP及UDP的网络交互处理又不一样，需要考虑的也不相同（如：TCP考虑包顺序处理及回调分发问题，UDP考虑丢包及无序处理）</p>
<blockquote>
<p>记录： iOS TCP链接使用 <code>GCDAsyncSocket</code>库；<br>UDP简单实现丢包处理方法，给文件分块，每个数据包的头部添加一个唯一标识序号的ID值，当接收到的包头部ID不是期望中的ID号，则判定丢包，将丢包ID发回服务端，服务端接收到丢包响应则重发丢失的数据包<br>UDP模拟TCP协议三次握手，这样对丢包处理有帮助</p>
</blockquote>
<p><strong>本文是博主15年读casa中<a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">网络层设计方案</a>的记录与思考总结。</strong></p>
<a id="more"></a>
<h4 id="聊聊AFN"><a href="#聊聊AFN" class="headerlink" title="聊聊AFN"></a>聊聊AFN</h4><p>AFN2.x特性：</p>
<ul>
<li>使用NSOperation，支持取消，不需占用完整线程（只在一个线程等待）</li>
<li>通过NSOperationQueue来进行并发任务数量限制（maxConcurrentOperationCount）</li>
<li>可暂停，可添加依赖</li>
<li>安全性设置（HTTPS、AFURLConnectOperationSSLPinningMode）</li>
<li>HTTP缓存（NSURLCache，数据缓存在本地sqlite里，需要服务器配合，设置请求头部信息）<br>注：在等待请求时只有一个Thread，在这个Thread上启动一个runloop监听NSURLConnection的NSMachPort类型源。start里面直接跳转到这个线程执行，在加入NSOperationQueue时，顶多start方法执行的时候占用一个线程，然后真正的发送请求和等待都是在这个NetworkRequestThread里面进行的（而最终访问网络并拉取数据不是这个线程，是NSURLConnection统一调度）。</li>
</ul>
<h4 id="网络交互中可以做哪些"><a href="#网络交互中可以做哪些" class="headerlink" title="网络交互中可以做哪些"></a>网络交互中可以做哪些</h4><table>
<thead>
<tr>
<th style="text-align:left">流程项</th>
<th style="text-align:left">可操作项</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">获取参数，统一配置</td>
<td style="text-align:left">进行参数验证</td>
</tr>
<tr>
<td style="text-align:left">根据API配置公共参数</td>
<td style="text-align:left">组件化配置HTTP头部、cookie、签名等</td>
</tr>
<tr>
<td style="text-align:left">构造请求</td>
<td style="text-align:left">设置拦截器进行拦截请求</td>
</tr>
<tr>
<td style="text-align:left">发出请求</td>
<td style="text-align:left">对已发出请求记录ID，统一管理（缓存）</td>
</tr>
<tr>
<td style="text-align:left">返回结果</td>
<td style="text-align:left">设置拦截器进行网络请求返回拦截，验证返回数据正确性、缓存数据</td>
</tr>
<tr>
<td style="text-align:left">展示数据</td>
<td style="text-align:left">根据API及业务层展示的需要，使用reformer将数据转化成任何你想要的东西（NSDictionary、DataList、View）</td>
</tr>
</tbody>
</table>
<h5 id="1-参数验证"><a href="#1-参数验证" class="headerlink" title="1.参数验证"></a>1.参数验证</h5><ul>
<li>注册账号或者发货信息等有必填选项，避免调用API产生不必要的开销</li>
<li>代码即文档，只需看这个验证函数就知道需要传什么参数</li>
</ul>
<h5 id="2-组件化"><a href="#2-组件化" class="headerlink" title="2.组件化"></a>2.组件化</h5><ul>
<li>使用工厂模式生产出不同的服务，每个服务配置好自己的线上线下url及版本号等信息（方便灵活），独立的组件来解耦API调用逻辑生产各种参数</li>
</ul>
<h5 id="3-根据不同API的配置使用2种策略"><a href="#3-根据不同API的配置使用2种策略" class="headerlink" title="3.根据不同API的配置使用2种策略"></a>3.根据不同API的配置使用2种策略</h5><ul>
<li>正在请求时，忽略新来的请求（当滚动tableview时，会频繁触发加载下一页的事件，如果当前APIManager正在加载下一页，那么就不需要再发送加载请求）</li>
<li>正在请求时，取消过去已发送的请求，执行现在请求（查询商品，切换筛选条件时，如果前一次筛选条件的请求正在进行中，那么就应当取消前一次请求，执行现在的请求 — 考虑到正在进行的请求取消设计）</li>
</ul>
<h5 id="4-通过将NSOperation保存requestID成NSMutableDictionary，随时依照requestID查找请求并支持取消"><a href="#4-通过将NSOperation保存requestID成NSMutableDictionary，随时依照requestID查找请求并支持取消" class="headerlink" title="4.通过将NSOperation保存requestID成NSMutableDictionary，随时依照requestID查找请求并支持取消"></a>4.通过将NSOperation保存requestID成NSMutableDictionary，随时依照requestID查找请求并支持取消</h5><h5 id="5-缓存"><a href="#5-缓存" class="headerlink" title="5.缓存"></a>5.缓存</h5><ul>
<li>接口返回的数据很少变动，不希望做重复请求</li>
<li>网络慢或者服务器等异常状况容灾</li>
</ul>
<p>引申：对于一些点赞和取消 频繁与网络交互的设计考虑</p>
<h4 id="网络层与业务层对接部分设计"><a href="#网络层与业务层对接部分设计" class="headerlink" title="网络层与业务层对接部分设计"></a>网络层与业务层对接部分设计</h4><h5 id="1-使用哪种交互模式与业务层做对接"><a href="#1-使用哪种交互模式与业务层做对接" class="headerlink" title="1.使用哪种交互模式与业务层做对接"></a>1.使用哪种交互模式与业务层做对接</h5><ul>
<li>以什么方式将数据交付给业务层<br>a.以Delegate为主，Notification为辅；尽可能减少跨层数据交流的可能，限制耦合；统一回调方法，便于调试和维护；在跟业务层对接的部分只采用一种对接方式，限制灵活性，以此来交换应用的可维护性（delegate对上下文有限制性）。<br>b.在网络请求和网络层接受请求的地方，使用Block没问题，但在获得数据交给业务方时，最好还是通过Delegate去通知到业务方。</li>
<li>交付什么样的数据给业务层<br>选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成View）转化好之后交付给View；对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据model，数据采用NSDictionary加const字符串key来表征，避免了使用model来表征带来的迁移困难，同时不失去可读性</li>
</ul>
<h5 id="2-是否有必要将API返回的数据封装成对象然后再交付给业务层"><a href="#2-是否有必要将API返回的数据封装成对象然后再交付给业务层" class="headerlink" title="2.是否有必要将API返回的数据封装成对象然后再交付给业务层"></a>2.是否有必要将API返回的数据封装成对象然后再交付给业务层</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">先定义一个protocol：</div><div class="line"></div><div class="line"><span class="meta">@protocol ReformerProtocol &lt;NSObject&gt;</span></div><div class="line">- (NSDictionary)reformDataWithManager:(APIManager *)manager;</div><div class="line"><span class="meta">@end</span></div><div class="line"></div><div class="line"></div><div class="line">在Controller里是这样：</div><div class="line"></div><div class="line"><span class="meta">@property (nonatomic, strong) id&lt;ReformerProtocol&gt; XXXReformer;</span></div><div class="line"><span class="meta">@property (nonatomic, strong) id&lt;ReformerProtocol&gt; YYYReformer;</span></div><div class="line"></div><div class="line"><span class="comment">#pragma mark - APIManagerDelegate</span></div><div class="line">- (void)apiManagerDidSuccess:(APIManager *)manager</div><div class="line">&#123;</div><div class="line">    NSDictionary *reformedXXXData = [manager fetchDataWithReformer:self.XXXReformer];</div><div class="line">    [self.XXXView configWithData:reformedXXXData];</div><div class="line"></div><div class="line">    NSDictionary *reformedYYYData = [manager fetchDataWithReformer:self.YYYReformer];</div><div class="line">    [self.YYYView configWithData:reformedYYYData];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">在APIManager里面，fetchDataWithReformer是这样：</div><div class="line">- (NSDictionary)fetchDataWithReformer:(id&lt;ReformerProtocol&gt;)reformer</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (reformer == nil) &#123;</div><div class="line">        <span class="keyword">return</span> self.rawData;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> [reformer reformDataWithManager:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>a.reformer是一个符合ReformerProtocol的对象，它提供了通用的方法供Manager使用；</p>
<p>b.API的原始数据（JSON对象）由Manager实例保管，reformer方法里面取Manager的原始数据（manager.rawData）做转换，然后交付出去。就比方是：莲蓬头的水管部分是Manager，负责提供原始水流（数据流），reformer就是不同的漏斗模式，换什么reformer就能出来什么形式的水（是不是有一种RAC信号的感觉）。</p>
<p>c.例子中举的场景是一个API数据被多个View使用的情况，体现了reformer的一个特点：<strong>可以根据需要改变同一数据来源的展示方式</strong>。比如API数据展示的是“附近的小区”，那么这个数据可以被列表（XXXView）和地图（YYYView）共用，不同的view使用的数据转化方式不一样，这就通过不同的reformer解决了。</p>
<h5 id="3-使用集约型调用方式还是离散型方式调用API"><a href="#3-使用集约型调用方式还是离散型方式调用API" class="headerlink" title="3.使用集约型调用方式还是离散型方式调用API"></a>3.使用集约型调用方式还是离散型方式调用API</h5><p>建议方式：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约型的手段，加密处理、URL拼接、组装请求和放飞请求，然而业务方调用API时，则是以离散的API方式来调用。<br>实际上，在博主之前做的项目中，账号系统及充值计费系统是属于集约型调用方式，主要是需求简单，调用接口多，返回数据处理逻辑简单。</p>
<blockquote>
<p>离散型单独对某个API请求的起飞和着陆过程可以进行AOP拦截，<strong>做到参数验证及返回数据缓存等操作</strong>，reformer机制就是基于离散型的API调用方式的。</p>
</blockquote>
<h4 id="设计代码层面"><a href="#设计代码层面" class="headerlink" title="设计代码层面"></a>设计代码层面</h4><h5 id="1-APIBaseManager存在的意义"><a href="#1-APIBaseManager存在的意义" class="headerlink" title="1.APIBaseManager存在的意义"></a>1.APIBaseManager存在的意义</h5><p><a href="https://github.com/casatwy/RTNetworking/blob/master/CTNetworking/CTNetworking/Components/BaseAPIManager/CTAPIBaseManager.h" target="_blank" rel="external">具体代码链接</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">BaseAPIManager的init方法里这么写：</div><div class="line"></div><div class="line">// 注意是weak。</div><div class="line"><span class="meta">@property (nonatomic, weak) id&lt;APIManager&gt; child;</span></div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    <span class="keyword">if</span> ([self conformsToProtocol:@protocol(APIManager)]) &#123;</div><div class="line">        self.child = (id&lt;APIManager&gt;)self;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        // 不遵守这个protocol的就让他crash，防止派生类乱来。</div><div class="line">        NSAssert(NO, <span class="string">"子类必须要实现APIManager这个protocol。"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protocol这么写，把原本要重载的函数都定义在这个protocol里面，就不用在父类里面写空方法了：</div><div class="line"><span class="meta">@protocol APIManager &lt;NSObject&gt;</span></div><div class="line"></div><div class="line"><span class="meta">@required</span></div><div class="line">- (NSString *)apiMethodName;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="meta">@end</span></div><div class="line"></div><div class="line">然后在父类里面如果要使用的话，就这么写：</div><div class="line"></div><div class="line">[self requestWithAPIName:[self.child apiMethodName] ......];</div></pre></td></tr></table></figure>
<ul>
<li>将子类的继承方式标准化 <code>&lt;APIManager&gt;</code></li>
<li>interceptor  同时支持外部拦截和内部拦截（TODO：说明内部拦截和外部拦截区别）</li>
<li>提供撤销网络请求的方法</li>
<li>获得数据后，使用reformer转化成图片、语音以及任何你希望得到的东西</li>
<li>可配置缓存</li>
<li>它是衔接业务逻辑和底层API调用的一个组件，其派生出来的各种APIManager在各个APP上都可重用、可移植，方便代码管理<br>blabla：同一个API不用重复写同一段调用代码和回调取数据逻辑，提高代码的组件化程度和集成度；Manager和Controller之间的关系可以不必非常紧密，切换API非常方便，降低了不必要的耦合（属于Model层）<h5 id="2-使用reformer（外观模式）"><a href="#2-使用reformer（外观模式）" class="headerlink" title="2.使用reformer（外观模式）"></a>2.使用reformer（外观模式）</h5>a.在处理单View对多API，以及在单API对多View的情况时，reformer提供了非常优雅的手段来响应这种需求，隔离了转化逻辑和主体业务逻辑，避免了维护灾难。<br>b.转化逻辑集中，且将转化次数转为只有一次。使用数据原型的转化逻辑至少有两次，第一次把json映射成对应model，第二次把model变成能被View处理的数据。而reformer一步到位。<br>c.业务数据和业务有了适当的隔离，将来如果业务逻辑有修改，换一个reformer改掉就好；若其他业务也有相同的数据转化逻辑，其他业务直接拿着这个reformer就可以用了，不需要重写。</li>
</ul>
<h4 id="网络层优化方案"><a href="#网络层优化方案" class="headerlink" title="网络层优化方案"></a>网络层优化方案</h4><ul>
<li>安全机制</li>
<li>请求优化（缓存，策略）</li>
<li>DNS缓存映射</li>
<li>链接复用（SPDY）</li>
</ul>
<p>参考：<a href="http://mrpeak.cn/blog/ios-network/" target="_blank" rel="external">深度优化iOS网络模块</a><br><a href="https://segmentfault.com/a/1190000004369289" target="_blank" rel="external">iOS网络优化之DNS映射</a></p>
<h4 id="还可以做哪些？"><a href="#还可以做哪些？" class="headerlink" title="还可以做哪些？"></a>还可以做哪些？</h4><ul>
<li>请求重发机制</li>
<li>批量网络请求发送，并统一设置他们的回调</li>
<li>设置有相互依赖的网络请求发送<br>扩展提问：网络部分token过期，如何处理？</li>
</ul>
<blockquote>
<p>遇到token失效就扔个Notification出去。XAPIManager请求失败（token失效，且在BaseApiManager中判断）后，扔出通知，将通知的object设为当前失败的这个Manager也就是XManager。然后中间人收到通知，记录下随着Notification过来的Object，也就是失败的那个Manager。然后在当前ViewController中present登陆页面。中间人收到Token刷新成功的回调，拿出刚才拿到的失败的那个Manager，直接调用[XManager loadData]，顺便dismiss掉登录页面，就好了。参数会由XManager的paramSource提供，你只管调loadData就好了，paramSource的重要性就体现在这里了。回调什么的也在你上一次失败时的页面内，整个过程完全无缝，且基本没有耦合</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;客户端网络层交互流程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取参数，统一配置&lt;/li&gt;
&lt;li&gt;根据API配置公共参数&lt;/li&gt;
&lt;li&gt;构造网络请求&lt;/li&gt;
&lt;li&gt;发送网络请求&lt;/li&gt;
&lt;li&gt;获取返回结果&lt;/li&gt;
&lt;li&gt;展示数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：此处还应该有个 &lt;code&gt;数据持久化&lt;/code&gt; 流程，因项目业务层逻辑及存储方案各不相同，本篇中不展开介绍&lt;br&gt;另：本篇幅中暂时只涉及到HTTP的请求，TCP及UDP的网络交互处理又不一样，需要考虑的也不相同（如：TCP考虑包顺序处理及回调分发问题，UDP考虑丢包及无序处理）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记录： iOS TCP链接使用 &lt;code&gt;GCDAsyncSocket&lt;/code&gt;库；&lt;br&gt;UDP简单实现丢包处理方法，给文件分块，每个数据包的头部添加一个唯一标识序号的ID值，当接收到的包头部ID不是期望中的ID号，则判定丢包，将丢包ID发回服务端，服务端接收到丢包响应则重发丢失的数据包&lt;br&gt;UDP模拟TCP协议三次握手，这样对丢包处理有帮助&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文是博主15年读casa中&lt;a href=&quot;https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html&quot;&gt;网络层设计方案&lt;/a&gt;的记录与思考总结。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>非典型程序猿羊年总结</title>
    <link href="https://www.devhua.com/2016/02/05/annual-summary-of-programmer/"/>
    <id>https://www.devhua.com/2016/02/05/annual-summary-of-programmer/</id>
    <published>2016-02-05T11:28:40.000Z</published>
    <updated>2017-04-24T04:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>14年底到15年年初的工作一言难尽，自己从嵌入式转到iOS开发，新的平台新的部门都需要重新学习和提高，压力可想而知。年初终于在我们大C司定岗，正式成为一个iOS开发，非常感谢我的三位iOS启蒙导师（李思哥哥、陆爷、彦群），他们帮助我跨过前期的障碍，也看到移动开发技术的未来。总体来讲，自己看到既年轻又活跃的天空，跟着团队也逐步认识到了一个创业团队的磨合期和碰撞期。<strong>风云变幻，莫笑少年愁</strong>。</p>
<a id="more"></a>
<p>毕竟是属于在集团内部创业的团队，业绩表现是团队影响最直观的因素，做出的产品销量达不到，则必须精简人员投入。于是乎，我也在3月底转入了新的部门，新的创业团队。<br>新的团队，自己又要重新熟悉团队产品及开发，当然这也给了我更多的机会。在逐步熟悉产品和技术的过程中，自己也跟着double dragon慢慢将iOS开发流程建立起来了（各种试错过程也是尴尬）。在这期间自己的技术成长还是蛮大的，团队初期的敏捷开发流程也很熟悉了。能够在团队里发挥这些作用，也使得自己收获到了成就感。</p>
<p>当然，除了技术方面，自己在团队协作方面也能提出一些见解，而团队的产品也是从无到有，经历了各种发布和改版。无数的讨论脑暴，和设计狮产品汪“对喷”，同样直面用户的“指手画脚”，都是自己一生的收获。感谢大家的努力，希望新的一年，咱们的产品能更加稳定、易用，抓住细节，优化体验。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>说到技术，太多细节，想想还是简而言之比较好。这一年自己的成长主要是对cocoa框架更加熟悉，对于HTTP网络层的封装有了较为深入的思考，蓝牙模块也比较熟悉，学习了swift开发等等。看了无数片博客，发现目前国内的iOS开发技术的开发性也很强，在这里要赞一下开源社区。与时俱进，自己经常关注微博，订阅（RSS）界内很多博客，还有些国外的论坛博客，都是非常好多资源。通过奇妙清单列出自己近期的学习计划，每周抽空回顾，找一个点好好研究下。这种方式帮助我了解很多iOS开发新奇时尚以及优化的做法。推荐大家使用。</p>
<h3 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h3><p>在年初时，大C司组建了自己的球队，作为篮球极度爱好者，果断参加。上半年还跑遍广州各种打比赛，气氛异常high。自己每周六下午都会跟大家打一次篮球，酣畅淋漓！而大广州在五六月份连续不断的下雨也是醉了，连着两个月打不了球，等到天气好点放晴了才突然发现，每周六打球的气氛也没有了。自己也转移到健身，从四月多开始，去健身房虐胸，在寝室里虐腹（Keep）。一度还带着团队的几个小伙伴一起健身，可是发现各种无法坚持下去。。年底公司的健身房重新开张后，自己去健身的频率更高了。有时一周五次，每次都是精疲力尽。我想，健身必定是一剂毒药，让人疯狂的爱上它。16年，希望自己继续坚持下去~</p>
<h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><blockquote>
<p>“要么旅行，要么读书，身体和灵魂必须有一个在路上。”</p>
</blockquote>
<p>可是，旅行和读书怎么想都是孤独的，是一个人的事情。有时候，累了、烦了，背起行囊就去逃离、去发现。</p>
<p>于是乎，在十二月初利用整年都没有使用的年假去了趟云南。都说“下关风，上关花，苍山雪，洱海月”是大理四绝！那时还特意把仙剑奇侠传电视剧看了一遍，“灵儿，我要送你回南诏国”，多么令人神往的地方呀~</p>
<p>昆明——丽江——大理，满满的行程也非常舒心！自由行的好处就在于每天不用那么赶，不会收导游脸色。自己想去哪就去哪，想待多久就多久。在丽江时，由于是淡季住在古城当地人开的客栈里，却被忽悠带到拉市海骑马，差点被坑了。丽江古城晚上非常热闹，很多酒吧夜市，但要注意好多酒托。现在古城商业化比较严重，也没看到什么想买的东西，于是直接去大理了。在大理古城外租一辆轿车，先开车围着洱海转了大半圈，到双廊住下后才发觉如此舒服。白天享受着冬日的暖阳，面对着洱海，心里非常放松。在暖暖客栈看看旅行人儿的留言，骑着小电驴围着洱海慢悠悠的绕着，享受着逃离现实般的梦幻。这一切回味起来真是让人迷恋。还记得当时就说了句，我一定还会再来！一路上也遇到了很多小伙伴，来自各地的朋友齐聚这里，还有一些直接在客栈打短工，都非常的有趣，都被洱海的风光所吸引。</p>
<p><strong>一年的总结就到这里，2016年，也不定什么目标了，只要对自己好一点，对自己狠一点。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工作&quot;&gt;&lt;a href=&quot;#工作&quot; class=&quot;headerlink&quot; title=&quot;工作&quot;&gt;&lt;/a&gt;工作&lt;/h3&gt;&lt;p&gt;14年底到15年年初的工作一言难尽，自己从嵌入式转到iOS开发，新的平台新的部门都需要重新学习和提高，压力可想而知。年初终于在我们大C司定岗，正式成为一个iOS开发，非常感谢我的三位iOS启蒙导师（李思哥哥、陆爷、彦群），他们帮助我跨过前期的障碍，也看到移动开发技术的未来。总体来讲，自己看到既年轻又活跃的天空，跟着团队也逐步认识到了一个创业团队的磨合期和碰撞期。&lt;strong&gt;风云变幻，莫笑少年愁&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.devhua.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="总结" scheme="https://www.devhua.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>GCD死锁大作战</title>
    <link href="https://www.devhua.com/2016/01/25/iOS-GCD-deadlock/"/>
    <id>https://www.devhua.com/2016/01/25/iOS-GCD-deadlock/</id>
    <published>2016-01-25T03:12:02.000Z</published>
    <updated>2017-12-14T09:53:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD死锁大作战"><a href="#GCD死锁大作战" class="headerlink" title="GCD死锁大作战"></a>GCD死锁大作战</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p><a href="https://en.wikipedia.org/wiki/Deadlock" target="_blank" rel="external">死锁（deadlock)</a> 通常是当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。此时就导致了deadlock！<br><img src="/2016/01/25/iOS-GCD-deadlock/dead-lock.png" alt="dead-lock.png"></p>
<h3 id="串行与并行"><a href="#串行与并行" class="headerlink" title="串行与并行"></a>串行与并行</h3><blockquote>
<p>在使用GCD的时候，我们会把需要处理的任务放到Block中，然后将任务追加到相应的队列里面，这个队列，叫做Dispatch Queue。然而，存在于两种Dispatch Queue，一种是要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列。这两种，均<strong>遵循FIFO原则</strong>。</p>
</blockquote>
<p><code>dispatch_get_global_queue</code>为全局并行队列</p>
<p><code>dispatch_get_main_queue</code>为主线程串行队列</p>
<a id="more"></a>
<p>自己也可以创建队列：</p>
<p>//创建串行队列<br><code>dispatch_queue_create(&quot;com.demo.serialQueue&quot;, DISPATCH_QUEUE_SERIAL)</code></p>
<p>//创建并行队列<br><code>dispatch_queue_create(&quot;com.demo.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT)</code></p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p>首先同步异步是对于线程来说的，主要区别是是否等待IO操作（并不一定是）执行完成，即是否阻塞当前线程，其中的 IO 操作肯定是别的线程去执行的</p>
<blockquote>
<p>并发执行的多个任务中可能存在多个线程，其中的多个线程有可能是同步执行的 也有可能是异步执行的</p>
</blockquote>
<p>//同步线程<br><code>dispatch_sync(某个队列信息,^(block))</code></p>
<p>//异步线程<br><code>dispatch_async(某个队列信息,^(block))</code> </p>
<h3 id="让我们来解锁吧"><a href="#让我们来解锁吧" class="headerlink" title="让我们来解锁吧"></a>让我们来解锁吧</h3><p><strong>当前串行队列里面同步执行当前串行队列就会死锁，解决的方法就是将同步的串行队列放到另外一个线程就能够解决。</strong></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSLog(@<span class="string">"1"</span>)<span class="comment">;</span></div><div class="line">dispatch_sync(<span class="name">dispatch_get_main_queue</span>(), ^&#123;</div><div class="line">   NSLog(@<span class="string">"2"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><del>这里的死锁不是因为在主线程执行，而是在main_queue内部的两个任务：dispatch_sync和NSLog相互等待导致。NSLog(@”2”)要等dispatch_sync执行完，而在执行NSLog(@”2”)执行完以前，dispatch_sync又不会结束。</del></p>
<p><strong>实际上，这里在主线程运行（串行线程），在主线程（当前串行队列）同步执行打印2时会产生互相等待而死锁。</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line"><span class="comment">//3会等2，因为2在全局并行队列里，不需要等待3，这样2执行完回到主队列，3就开始执行</span></div><div class="line"><span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div></pre></td></tr></table></figure>
<p>这里不死锁，同步任务在全局并行队列中，因此2执行完就跳转到主线程执行3。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(<span class="string">"com.starming.gcddemo.serialqueue"</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></div><div class="line">NSLog(@<span class="string">"1"</span>)<span class="comment">;</span></div><div class="line">dispatch_async(<span class="name">serialQueue</span>, ^&#123;</div><div class="line">   NSLog(@<span class="string">"2"</span>)<span class="comment">;</span></div><div class="line">   //串行队列里面同步一个串行队列就会死锁</div><div class="line">   dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</div><div class="line">       NSLog(@<span class="string">"3"</span>)<span class="comment">;</span></div><div class="line">   &#125;)<span class="comment">;</span></div><div class="line">   NSLog(@<span class="string">"4"</span>)<span class="comment">;</span></div><div class="line">&#125;)<span class="comment">;</span></div><div class="line">NSLog(@<span class="string">"5"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"1"</span>);</div><div class="line">   <span class="comment">//回到主线程发现死循环后面就没法执行了</span></div><div class="line">   <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"2"</span>);</div><div class="line">   &#125;);</div><div class="line">   <span class="built_in">NSLog</span>(<span class="string">@"3"</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"4"</span>);</div><div class="line"><span class="comment">//死循环</span></div><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">   <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>以上部分欢迎讨论</strong></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://objccn.io/issue-2-1/#dead_locks" target="_blank" rel="external">并发编程</a><br><a href="https://www.zybuluo.com/MicroCai/note/64272" target="_blank" rel="external">Effective Objective-C Notes：GCD 实现同步锁</a><br><a href="http://www.jianshu.com/p/fbe6a654604c" target="_blank" rel="external">细说GCD（Grand Central Dispatch）如何用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD死锁大作战&quot;&gt;&lt;a href=&quot;#GCD死锁大作战&quot; class=&quot;headerlink&quot; title=&quot;GCD死锁大作战&quot;&gt;&lt;/a&gt;GCD死锁大作战&lt;/h2&gt;&lt;h3 id=&quot;什么是死锁&quot;&gt;&lt;a href=&quot;#什么是死锁&quot; class=&quot;headerlink&quot; title=&quot;什么是死锁&quot;&gt;&lt;/a&gt;什么是死锁&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;死锁（deadlock)&lt;/a&gt; 通常是当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。此时就导致了deadlock！&lt;br&gt;&lt;img src=&quot;/2016/01/25/iOS-GCD-deadlock/dead-lock.png&quot; alt=&quot;dead-lock.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;串行与并行&quot;&gt;&lt;a href=&quot;#串行与并行&quot; class=&quot;headerlink&quot; title=&quot;串行与并行&quot;&gt;&lt;/a&gt;串行与并行&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在使用GCD的时候，我们会把需要处理的任务放到Block中，然后将任务追加到相应的队列里面，这个队列，叫做Dispatch Queue。然而，存在于两种Dispatch Queue，一种是要等待上一个执行完，再执行下一个的Serial Dispatch Queue，这叫做串行队列；另一种，则是不需要上一个执行完，就能执行下一个的Concurrent Dispatch Queue，叫做并行队列。这两种，均&lt;strong&gt;遵循FIFO原则&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch_get_global_queue&lt;/code&gt;为全局并行队列&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dispatch_get_main_queue&lt;/code&gt;为主线程串行队列&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Change Your App Icon at build time</title>
    <link href="https://www.devhua.com/2016/01/06/Change-Your-App-Icon-at-Build-time/"/>
    <id>https://www.devhua.com/2016/01/06/Change-Your-App-Icon-at-Build-time/</id>
    <published>2016-01-06T10:48:40.000Z</published>
    <updated>2017-04-24T04:06:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>为了<strong>区分线上版本、测试版本以及调试版本</strong>，我们在开发过程中一般会修改bunlde Id以便在一个设备上安装不同版本的App。然而问题来了，如何快速区分出桌面上的App是什么版本呢？最直观的就是<strong>改变App图标</strong>，达到显而易见的目的。</p>
<hr>
<p>在看了<a href="http://www.cocoachina.com/ios/20150909/13354.html" target="_blank" rel="external">这篇译文</a>后，利用脚本可以非常便利的实现这个需求（<a href="https://www.raywenderlich.com/105641/change-app-icon-build-time" target="_blank" rel="external">这是原文</a>）。虽然译文翻译有些问题，但还是确实让大家能伸手一把（原文作者真心是手把手教学）。</p>
<a id="more"></a>
<h2 id="实际工作"><a href="#实际工作" class="headerlink" title="实际工作"></a>实际工作</h2><p>实际上，原文中对脚本解释的非常清楚，我这里简单记录下，顺便提一下注意点。</p>
<p><strong>实现原理</strong>：在Xcode下build时，运行一个shell脚本，使用ImageMagick这个图像处理软件套件进行图标转换和组合，替换掉原本设置的AppIcon。</p>
<p><strong>实现步骤</strong>：</p>
<ul>
<li>使用brew安装ImageMagick brew install ImageMagick</li>
<li>安装Ghostscript brew install ghostscript 它提供了支持ImageMagick的字体</li>
<li>将需要组合的调试图片放到项目根目录</li>
<li>将以下脚本加入到项目中</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">IFS=$<span class="string">'\n'</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"ready change app icon"</span></div><div class="line">buildNumber=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleVersion"</span> <span class="string">"<span class="variable">$INFOPLIST_FILE</span>"</span>)</div><div class="line">versionNumber=$(/usr/libexec/PlistBuddy -c <span class="string">"Print CFBundleShortVersionString"</span> <span class="string">"<span class="variable">$INFOPLIST_FILE</span>"</span>)</div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> $(find <span class="variable">$&#123;SRCROOT&#125;</span> -name <span class="string">"AppIcon76x76@2x~ipad.png"</span>)</div><div class="line">PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/<span class="built_in">local</span>/bin</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">changeAppIcon</span></span> () &#123;</div><div class="line">    BASE_IMAGE_NAME=<span class="variable">$1</span></div><div class="line">    TARGET_PATH=<span class="string">"<span class="variable">$&#123;BUILT_PRODUCTS_DIR&#125;</span>/<span class="variable">$&#123;UNLOCALIZED_RESOURCES_FOLDER_PATH&#125;</span>/<span class="variable">$&#123;BASE_IMAGE_NAME&#125;</span>"</span></div><div class="line">    BASE_IMAGE_PATH=$(find <span class="variable">$&#123;SRCROOT&#125;</span> -name <span class="variable">$&#123;BASE_IMAGE_NAME&#125;</span>)</div><div class="line">    WIDTH=$(identify -format %w <span class="variable">$&#123;BASE_IMAGE_PATH&#125;</span>)</div><div class="line">    FONT_SIZE=$(<span class="built_in">echo</span> <span class="string">"<span class="variable">$WIDTH</span> * .2"</span> | bc <span class="_">-l</span>)</div><div class="line">    <span class="built_in">echo</span> <span class="string">"CFBundleVersion = <span class="variable">$buildNumber</span>"</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"CFBundleShortVersionString = <span class="variable">$versionNumber</span>"</span></div><div class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CONFIGURATION&#125;</span>"</span> == <span class="string">"Debug"</span> ]; <span class="keyword">then</span></div><div class="line">    convert debugRibbon.png -resize <span class="variable">$WIDTHx</span><span class="variable">$WIDTH</span> resizedRibbon.png</div><div class="line">    convert <span class="variable">$&#123;BASE_IMAGE_PATH&#125;</span> -fill white -font Times-Bold -pointsize <span class="variable">$&#123;FONT_SIZE&#125;</span> -gravity south -annotate 0 <span class="string">"<span class="variable">$buildNumber</span>"</span> - | composite resizedRibbon.png - <span class="variable">$&#123;TARGET_PATH&#125;</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;CONFIGURATION&#125;</span>"</span> == <span class="string">"AdHoc"</span> ]; <span class="keyword">then</span></div><div class="line">    convert betaRibbon.png -resize <span class="variable">$WIDTHx</span><span class="variable">$WIDTH</span> resizedRibbon.png</div><div class="line">    convert <span class="variable">$&#123;BASE_IMAGE_PATH&#125;</span> -fill white -font Times-Bold -pointsize <span class="variable">$&#123;FONT_SIZE&#125;</span> -gravity south -annotate 0 <span class="string">"<span class="variable">$buildNumber</span>"</span> - | composite resizedRibbon.png - <span class="variable">$&#123;TARGET_PATH&#125;</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">changeAppIcon <span class="string">"AppIcon76x76@2x~ipad.png"</span></div><div class="line">changeAppIcon <span class="string">"AppIcon76x76~ipad.png"</span></div><div class="line">changeAppIcon <span class="string">"AppIconx40x40@2x~ipad.png"</span></div><div class="line">changeAppIcon <span class="string">"AppIcon40x40~ipad.png"</span></div><div class="line">changeAppIcon <span class="string">"AppIcon29x29@2x~ipad.png"</span></div><div class="line">changeAppIcon <span class="string">"AppIcon29x29~ipad.png"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"finish"</span></div></pre></td></tr></table></figure>
<p><strong>需要注意的几点有</strong></p>
<ul>
<li>路径问题（可以看到以上脚本跟原文中的有些差别）</li>
<li>图片名称，需要修改项目中AppIcon的命名</li>
<li>获取编译构建号，根据不同版本写入AppIcon中</li>
</ul>
<p>最后效果类似下图<br><img src="http://cc.cocimg.com/api/uploads/20150907/1441608383827075.png" alt=""></p>
<p>在这里再分享个<strong>根据githash更新编译构建号的脚本</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Githash=<span class="variable">$(git --git-<span class="built_in">dir</span>="$&#123;PROJECT_DIR&#125;/.git" --work-tree="$&#123;PROJECT_DIR&#125;" rev-parse --short HEAD)</span></div><div class="line">RevisionNumber=<span class="variable">$(git rev-list --count HEAD)</span></div><div class="line">BuildTimestamp=<span class="variable">$(date +'%Y-%m-%d %H:%M')</span></div><div class="line">GitCommit=</div><div class="line">bundleVersion=$(/usr/libexec/PlistBuddy -c <span class="string">"print CFBundleShortVersionString"</span> <span class="string">"$INFOPLIST_FILE"</span>)</div><div class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :CFBundleVersion $RevisionNumber"</span> <span class="string">"$INFOPLIST_FILE"</span></div><div class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :BuildTimestamp $BuildTimestamp"</span> <span class="string">"$INFOPLIST_FILE"</span></div><div class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :GitCommit $Githash"</span> <span class="string">"$INFOPLIST_FILE"</span></div></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><strong>目前该功能已经集成到项目中，配合jenkins集成打包，各种轻松无压力~</strong><br>以后可以在此基础上加一些其他功能，等需要时再加上咯。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;为了&lt;strong&gt;区分线上版本、测试版本以及调试版本&lt;/strong&gt;，我们在开发过程中一般会修改bunlde Id以便在一个设备上安装不同版本的App。然而问题来了，如何快速区分出桌面上的App是什么版本呢？最直观的就是&lt;strong&gt;改变App图标&lt;/strong&gt;，达到显而易见的目的。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在看了&lt;a href=&quot;http://www.cocoachina.com/ios/20150909/13354.html&quot;&gt;这篇译文&lt;/a&gt;后，利用脚本可以非常便利的实现这个需求（&lt;a href=&quot;https://www.raywenderlich.com/105641/change-app-icon-build-time&quot;&gt;这是原文&lt;/a&gt;）。虽然译文翻译有些问题，但还是确实让大家能伸手一把（原文作者真心是手把手教学）。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://www.devhua.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="iOS" scheme="https://www.devhua.com/tags/iOS/"/>
    
  </entry>
  
</feed>
